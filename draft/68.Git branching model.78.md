# 68.Git branching model.78
## <a name="index"></a> 目录
- [引子](#start)
- [index 1](#index1)
  - [index 12](#index12)
- [参考资料](#reference)


## <a name="start"></a> 引子
在 Git 工作流相关资料的时候，看到这些内容，根据个人理解对相关内容进行翻译，以作参考之用。

## 简介
Git 工作流是最早推荐使用 Git 分支的工作流之一，它受到了很多关注。原文见 [A successful Git branching model][url-article-4]。文中主要是讲的是分支策略和发布管理，下面是整体示意图。

![68-git-modal][url-local-1]

## 分散但集中
使用和良好配合这个分支模型的的库是一个“真正”的主库。注意这个库只是被认为是一个主库（由于 Git 是一个分布式版本控制系统，在技术上并没有这样的一个处于中心的库）。我们将这个库称为 origin，因为这个名称对所有 Git 用户都很熟悉。

每个开发者拉取并推送到 origin 。但是除了集中的推送-拉取关系之外，每个开发人员还可以从其他对等方拉取更改来组成子团队。例如，在过早的把进行中的工作推送到 origin 之前，这将有助于多个开发者共同合作开发一个大的新功能。在下面的图示中，就拥有 Alice and Bob、 Alice and David 和 Clair and David 子团队。

![68-centr-decentr][url-local-2]

## 主分支
主库有两个一直存在的主要分支：
-  master
-  develop

![68-main-branches][url-local-3]

在 origin 的 master 分支，对于每一个 Git 用户来说应该是熟悉的。跟 master 分支平行的另外一个分支称为 develop 。

我们认为 origin/master 分支将作为总是处于一个生成就绪状态的主分支。

我们认为 origin/develop 分支将作为总是处于下一个版本中最新开发变更状态的主分支。有些人称为为“集成分支”，这是所有自动夜间构建的来源。

当在 develop 分支的源码达到一个稳定点并准备发布时，所有的变动应该以某种方式合并回 master 分支，只有添加一个发布数字标签。详细的该如何做，后面将会详细讨论。

因此，每次更改合并回主版本时，根据定义，这是一个新的生产版本。我们在这方面往往非常严格，因此理论上，我们可以使用 Git hook 脚本，在每次 master 上有提交时，自动构建并将其部署到生产环境的服务器上。

## 辅助分支
紧接着主分支的，我们的开发模式使用一系列辅助分支，用来帮助团队成员之间并行开发，简化跟踪功能，为产品发布做好准备，并快速修复实际生产问题。跟主分支不同的是，这些分支总是有一个有限的生命周期，因为它们最后都将会被删除。

我们可能使用到的不同类型分支：
- Feature branches
- Release branches
- Hotfix branches

每一个分支都有一个明确的目的，并有严格的规则规定那个分支是它们的源分支，那个分支是它们合并的目标分支。线面就分别进行介绍。

## Feature 分支
- 可能来源分支 ： develop
- 必须合回分支 ： develop
- 分支命名约定 ： 除了 master, develop, release-\*, hotfix-\* 之外任何形式

feature 分支是用来开发将要发布的新功能或一个未来的版本。当开始开发一个特性时，包含该特性的目标版本可能在那时是未知的。feature分支的本质是只要特性处于开发中，它就存在，但最终将被合并回 develop 或者废弃。

feature 分支通常指存在于开发人员的库中，不会在 origin 。

### 创建 feature 分支
当开始开发一个新特性时，基于 develop 创建分支。
```git
$ git checkout -b myfeature develop
```

### 合并完成的 feature 到 develop
完成的特性可以合并到 develop 分支中，以明确地将它们添加到即将发布的版本中：
```git
$ git checkout develop
$ git merge --no-ff myfeature
$ git branch -d myfeature
$ git push origin develop
```
参数 --no-ff 将会在合并时，始终创建一个新的提交对象，即使这个合并可以通过快进来执行。这个避免丢失历史存在的 feature 分支信息，并将所有的提交组合在一起。比较：

![merge-without-ff][url-local-4]

在后一个例子中，从 Git 历史中是没办法看出哪些提交实现了一个新特性，你必须手动读取所有日志消息。同样，撤销一个完整的特性是一个很头疼的事情，而如果使用了 --no-ff 标志，则很容易就可以实现。

的确，这个将会创建更多的提交对象，但收益远远大于成本。

## Release 分支
- 可能来源分支 ： develop
- 必须合回分支 ： develop 和 master
- 分支命名约定 ： release-\*


<div align="right"><a href="#index">Back to top :arrow_up:</a></div>


## <a name="reference"></a> 参考资料
- [A successful Git branching model][url-article-1]


[url-base]:https://xxholic.github.io/segment

[url-article-1]:https://nvie.com/posts/a-successful-git-branching-model/

[url-local-1]:../images/68/git-model.png
[url-local-2]:../images/68/centr-decentr.png
[url-local-3]:../images/68/main-branches.png
[url-local-4]:../images/68/merge-without-ff.png
